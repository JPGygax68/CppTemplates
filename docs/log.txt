2014-09-17
==========

A few thoughts about templates:

- Multi-file templating:
  
  - Filenames should accept placeholders that can change not only the name of the produced file(s), but also their location (i.e. the placeholder can potentially be replaced with a folder hierarchy instead of just a string. [This should not be too difficult if the generated files are treated as a flat list rather than a tree.]
  
  - Every template file could generate zero, one or several instances.
  
  - Re-instancing the same version of a template with different parameters can add, move, or delete files, in addition to modifying their content
  
  - Re-instancing a new version of a template with the same parameters can do the same, and additionally lead to "orphaned" files.
  
  - Updating the template and changing the parameters should never be done in a single operation.
  
- Parameters:
  
  - The parameters should be collected in the form of a "response file".
  
  - Ideally, the responses would be named, not purely sequential; they could thus be considered parameters rather than just responses.
  
  - This is stuff for a separate library ["GPCResponses"].
  
  
2014-09-16
==========

Have begun making my template fit for header-only libraries. I copied the test scripts and now have basically two "sub" test suites, one for building a shared library and one for building a header-only one (static still pending).

The present problem is that I bumped into the need (or wish) for using templating, because the declspec() attributes of MSVC turn out to be incompatible with header-only libraries. 

While it would be easy to make the corresponding preprocessor code conditional, this is fairly ugly for code that has no chance of ever being built as a shared library.

In fact, there is a high-level decision to be taken here: should the library template support converting the library to a different type after the scaffolding, or should it try to remove all unnecessary code so the programmer only gets what he needs?

The latter approach is the one that would require templating, while generating preprocessor definitions from CMakeLists.txt would probably be sufficient for the former.

I shall go with the former approach, at least for now (starting tomorrow). If support is to be added later on for cleaning up unneeded code sections, Google's CTemplate seems to be a usable library, as is the C++ Mustache port that can be found here: https://github.com/mrtazz/plustache .


2014-09-13
==========

Ok! Some success at least, let's step back and see what I've accomplished.

I have a "Library" template that I've put under the control of a set of test scripts.

The template itself is small: all it contains is header file that defines a single class with a single method; a source file implementing that method; the source for a test suite executable; and a CMakeLists.txt file controlling the whole.

The real value though comes from the test scripts. Those are presently implemented as Windows CMD batches only, and cover the following functionality:

- The template can be used to build a (shared) library.
 
- That library can be found by CMake without installing (that is, it can be used from the build tree).

- The library can be linked with a CMake target of type "executable".

- The test suite will report a failure before an (artificial) "bug" is "fixed".

- The test suite will report success after that bug is fixed.

- The library can be found by CMake once it has been installed and its build tree deleted.

I think the template might be usable in its present form, though there are lots of things I haven't implemented or even though about yet:

- I'm not testing debug and release builds.

- I haven't even manually tested creating a static library instead of a shared one; but I'd like to test that option using the same set of scripts (meaning I'd have to introduce parameters).

- There is no support for custom build tools (such as GPCBin2C) in the CMakeLists.txt template. 
  (Not sure how I would go about testing that.)

- No support for a generated/templatized config header (e.g. mylib_config.h).

- There is no support for a configurable top-level namespace (such as Boost has).

- There is no support for a sample/demo program.

- There is no LICENSE or README file.

- The test suite template is very simple and does not contain any code snippets.

- There is only one template so far, the one for libraries. I need to be able to create executable projects too.

2014-09-06
==========

Yet another new project: GPC C++ templates.

The goal is to make it dead easy to create new portable C++ software, be it libraries (static or shared), tools, or applications.

This is supposed to be a long-term effort, and is a serious undertaking, which means that the templates, any accompanying tools, etc., must come with test cases. An untested feature is not a feature.

The whole template library shall be test-driven, so the first task is to get a test system going along with the first template, which shall be a C++ library.

I'm hesitating as to how to implement the scripting (i.e. how to run the tests). I'm seriously considering doing this in C++ all the way through. The alternatives are unattractive: bash is great for scripting, but not there under Windows; other scripting tools like Python, Node etc. are also great, but are serious products of their own travelling with their own luggage.

Before taking that decision, what exactly do I need ? Fortunately, not much at all:

- I need to be able to run the test suites for each of the templates (each template will have its own test suite), and determine whether they ran successfully or not.

That's about it. Thinking about it, CMake is all I really need (plus maybe a bootstrap one-liner in bash + cmd).

-> Hm. CMake seems to generate project and solution files even when the only command is message("Hello world"). Investigating...
  - Came across "ProjectGenerator". Am gonna give it a shot, looks like an alternative to this whole templates business.
    ... well, maybe not after all. But I have the downloaded zip ready just in case.

-> Batch files it is, for now at least. They should, must, remain super-simple though.

- I think SED (Stream EDitor) is the answer to generating test cases.

-----

Some success! I have built a test script that takes a super-simple template, does a very small bit of customization, then calls CMake to build and install.

Much remains to do: 

- Testing the results:
  - Can the library's build tree be found ?
  - Can it be used from its installed location ?
  - Does the package correctly report its name (with namespace) and version ?

- Add tests as part of the template, and test that part of the functionality as well.
  
- Support for additional components
